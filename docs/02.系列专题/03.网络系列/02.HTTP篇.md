---
title: HTTP篇
date: 2022-01-06 10:38:17
permalink: /topic/pages/220106103817/
categories:
    - 系列专题
    - 为什么系列
tags:
    - 计算机网络
    - HTTP篇
---

## 1. HTTP基础知识

概念：超文本传输协议，即：一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。

> 常见状态码

* 1xx
1xx提示信息，协议处理中的一种中间状态
  
* 2xx
2xx服务器成功处理了客户端的请求
  
| 状态码 | 英文概念 | 中文描述 |
| :---: | :---: | :---: |
| 200 | ok | 如果是非**HEAD**请求，服务器返回的响应头都会有body数据 |
| 204 | no content | 响应头没有body数据 |
| 206 | partial content | 应用于HTTP分块下载或断电续传，表示响应返回的body数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。 |

* 3xx
3xx客户端请求的资源发生了变动，需要客户端使用新的URL重新发送请求，即重定向  11:15 14:15 13:00

| 状态码 | 英文概念 | 中文描述 |
| :---: | :---: | :---: |
| 301 | moved permanently | 永久重定向，说明请求的资源已经不存在了，需要改用新的URL再次访问 |
| 301 | templated permanently | 临时重定向，说明请求的资源还存在，只是暂时需要使用新的URL访问 |
| 304 | not modified | 资源未修改，重定向已存在的缓冲文件，也称为缓存重定向 |

301 和 302 都会在响应头里使用字段**Location**，指明后续要跳转的URL，浏览器会自动重定向新的URL。

* 4xx
4xx代表客户端发送的报文有误，服务器无法处理

| 状态码 | 英文概念 | 中文描述 |
| :---: | :---: | :---: |
| 400 | bad request | 客户端请求的报文有错误，只是个笼统的错误 |
| 403 | forbidden | 服务器禁止访问资源，并不是客户端的请求出错 |
| 404 | not found | 请求的资源在服务器上不存在或未找到，所以无法提供给客户端 |

* 5xx
5xx表示客户端请求报文正确，但是服务器处理时内部发生错误，属于服务端的错误码

| 状态码 | 英文概念 | 中文描述 |
| :---: | :---: | :---: |
| 500 | internal server error | 笼统的错误码，服务器发生了什么错误，并不知道 |
| 501 | not implemented | 客户端请求的功能还不支持，类似"即将开业，敬请等待"的意思 |
| 502 | bad gateway | 服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误 |
| 503 | service unavailable | 服务器当前很忙，暂时无法响应服务器，类似"网络服务正忙，请稍后再试"的意思 |


## 3. HTTP特性

优点：
* 简单
HTTP报文格式就是`header + body`，头部信息也是 `key-value` 简单文本的形式，易于理解，降低了学习和使用的门槛。
  
* 灵活和易于扩展
HTTP协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充。
同时，HTTP由于是工作在应用层，它的下层可以随意变化。
HTTPS是HTTP与TCP之间增加了SSL/TLS安全传输层，HTTP/3甚至把TCPP层换成了基于UDP的QUIC
  
* 应用广泛和跨平台

缺点：
* 无状态双刃剑
好处：服务器不用记忆HTTP的状态，所以不需额外的资源来记录状态信息，这样能减轻服务器的分担，能够把更多的CPU和内存用来对外提供服务。
坏处：既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦，需要借助cookie、session机制来完成。  
  
* 明文传输双刃剑
好处：易于查看传输过程中的信息，方便调试F12和wireshark抓包
坏处：信息相当于裸奔，不安全  
  
## 4. HTTP与HTTPS

HTTP协议是基于TCP/IP，并且使用了「请求 - 应答」的通信模式。

4.1 HTTP/1.0的性能：
* 每次的请求都会新建一次TCP连接(都需要进行三次握手，四次挥手)，而且是串行请求，导致很多无畏的TCP建立连接和断开，增加了通信开销。

4.2 HTTP/1.1的性能：
* 长连接，也叫持久连接，采用保活机制
* 管道网络传输，即可在同一个TCP连接里面，客户端可以发起多个请求，只要第一个发出去了，不必等其回来，就可以发第二个请求出去，可以**减少整体的响应时间**，
但服务端还是需要串行来操作客户端的请求。
这样带来的问题：
就会导致对头阻塞问题，从而当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据。
  
4.3 HTTPS解决了HTTP的哪些问题
HTTP是明文传输，所以安全上存在以下三个风险：
* 窃听风险，比如通信链路上可以获取通信内容，用户号容易没。
* 篡改风险，比如强制置入垃圾广告
* 冒充风险，比如冒充淘宝网站

HTTPS可以很好地解决上述风险：
* 信息加密：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没
* 校验机制：无法篡改通信内容，篡改了就不能正常显示
* 身份证书：证明淘宝是真的淘宝

4.4 HTTPS是如何解决上面的三个风险
> 混合加密实现信息的机密性，解决窃听的风险、摘要算法实现完整性，解决篡改的风险、将服务器公钥放入到数字证书中，解决了冒充的风险

* 混合加密：
浏览器和服务器先通过RSA非对称加密交换AES口令，接下来双方通信实际上采用的是速度较快的AES对称加密。

* 数字证书
客户端先向服务端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。
为了保证公钥不被篡改，需要借助第三方权威机构CA（数字证书认证机构），将服务器公钥放在数字证书中，只要证书是可信的，公钥就是可信的。

SSL/TLS的「握手阶段」涉及**四次通信**，可见下图：
![img](https://mmbiz.qpic.cn/mmbiz_jpg/J0g14CUwaZfXG1113Sjm0iaOXfoOv0tlUMRTqQDVOJHMZe3JoN5TqSb0uYicOqMH2qHgic7M6rtCrjPOToDjBm11A/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
> 1. 客户端给出协议版本号、一个客户端生成的随机数，以及客户端支持的加密方法
> 2. 服务端确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数
> 3. 客户端确认数字证书有效，然后生成一个新的随机数，并使用数字证书中的公钥加密这个随机数，发给服务端
> 4. 服务端使用自己的私钥，获取客户端的随机数
> 5. 客户端和服务端根据约定的加密方法，使用前面的三个随机数，生成"对话秘钥"(session key)，用来加密接下来的整个对话过程。

## 5. HTTP/1.1、HTTP/2.0、HTTP/3.0演变
摘要算法用来确保数据没有篡改，非对称加密算法可以对数据进行加解密，签名算法可以确保数据完整性和抗否认性，把这些算法集合到一起，并搞一套完善的标准就是数字证书。
数字证书采用链式签名管理，顶级的Root CA证书已内置在操作系统中。
数字证书存储的是公钥，可以安全公开，而私钥必须严格保密。

![img](https://mmbiz.qpic.cn/mmbiz_jpg/J0g14CUwaZfXG1113Sjm0iaOXfoOv0tlUy5OSaaTftjD7JmdU4AUMnlrGOWXnMYss5sCxMMTPUibLeHIgdsdkklQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

> 5.1 说说HTTP/1.1相比HTTP/1.0提高了什么性能
> * 使用TCP长链接的方式改善了HTTP/1.0短链接造成的性能开销
> * 支持管道(pipeline)网络传输，可以并行发送请求，而不用串行等待发送请求，减少了整体的响应时间
> 
> 5.2 HTTP/1.1的性能瓶颈
> * 请求/响应头部未经压缩就发送，首部信息越多延迟越大。只能压缩body部分
> * 发送冗长的首部，每次互相发送相同的首部造成的浪费较多
> * 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直接收不到数据，从而造队头阻塞
> * 没有请求优先级
> * 请求只能从客户端开始，服务端只能被动响应
> 
> 5.3 HTTP/2.0相比HTTP/1.1做了哪些优化
> * 头部压缩：hpack算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不会发送同样字段了，只发送索引号
> * 二进制格式：头信息和数据体都是二进制，并且统称为帧
> * 数据流
> * 多路复用
> * 服务器推送
> 
> 5.4 HTTP/3.0相比HTTP/2.0做了哪些优化
> * HTTP/2.0主要的问题：多个HTTP请求在复用一个TCP连接，下层的TCP协议是不知道有多少HTTP请求的，所以一旦发生了丢包，就会触发TCP重传机制，这样在一个TCP连接中的所有的HTTP请求都必须等待这个丢了的包被重传回来。
> * HTTP/1.1 中的管道（ pipeline）传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了; HTTP/2 多请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。这都是基于 TCP 传输层的问题，所以 HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！
> * 大家都知道 UDP 是不可靠传输的，但基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输。
> * QUIC 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响。
> * TL3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack。
> * HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 TLS/1.3 的三次握手。QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数。
> * QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题。所以 HTTP/3 现在普及的进度非常的缓慢，不知道未来 UDP 是否能够逆袭 TCP。

![img](https://mmbiz.qpic.cn/mmbiz_jpg/J0g14CUwaZfXG1113Sjm0iaOXfoOv0tlUyP3HNicKS2J21mHQD9EepOiciakC8nRkrX9C3I0hjC6Fhjvd4nLiakuLeg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)