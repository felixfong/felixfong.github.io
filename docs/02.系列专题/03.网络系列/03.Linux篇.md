---
title: Linux篇
date: 2022-07-04 10:26
permalink: /topic/pages/202207041026/
categories:
- 系列专题
- 为什么系列
tags:
- 计算机网络
- Linux网络协议篇
---

## 0. 概述
在TCP/IP网络分层模型里，整个协议分成了物理层、链路层、网络层、传输层和应用层。物理层对应网卡和网线，应用层对应常见的Nginx和Ftp等各种应用。
Linux实现的是链路层、网络层和传输层这三层。

在Linux内核实现中，链路层协议靠网卡驱动来实现，内核协议栈来实现网络层和传输层。内核对更上层的应用层提供socket接口来供用户进程访问
![img](https://raw.githubusercontent.com/felixfong/illustrations/main/png/linux%20tcp/ip%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B.png "tcp/ip网络分层模型")

首先，在开始收包之前，Linux需要做很多的准备工作：
* 创建ksoftirqd线程，为它设置好它自己的线程函数，后面用它来处理软中断
* 协议栈注册，Linux要实现许多协议，比如arp、icmp、ip、udp、tcp，每一个协议都会将自己的处理函数注册一下，方便包来了迅速找到对应的处理函数
* 网卡驱动初始化，每个驱动都有一个初始化函数，内核会让驱动也初始化一下，在这个初始化过程中，把自己的DMA准备好，把NAPI的poll函数告诉内核
* 启动网卡，分配RX、TX队列，注册中断对应的处理函数

当上面ready之后，就可以打开硬中断，等待数据包的到来了。
当数据到来了之后，第一个迎接它的是网卡：
* 网卡将数据帧DMA到内存Ring Buffer中，然后向CPU发起中断通知；
* CPU响应中断请求，调用网卡启动时注册的中断处理函数
* 中断处理函数几乎没干啥，就发起了软中断
* 内核线程ksoftirqd线程发现有软中断请求到来，先关闭硬中断
* ksoftirqd线程开始调用驱动的poll函数收包
* poll函数将收到的包送到协议栈注册的ip_rcv函数中
* ip_rcv函数再将包发送到udp_rcv函数中（对于tcp包发送到tcp_rcv中）

## 1. 网络性能工具
* 系统能打开的文件描述符
/proc/sys/fs/file-max
* 配置和查看网络接口 ifconfig/ip
* 查看网络连接数 ss -ltnp
* 查看网络接口的网络收发情况 sar
* 查看进程的网络收发情况 nethogs
* 查看ip的网络收发情况 iftop
* 查看和配置网络接口 ethool
* 网络抓包工具 tcpdump
* 配置和管理防火墙及NAT规则 iptables
* 剖析内核协议栈的性能 perf
* 动态追踪内核协议栈的行为 systemtap/bcc

** CPU **
* uptime：快速查看系统CPU负载情况：1分钟、5分钟、15分钟
* top：整体负载情况，通过P来排序CPU，M排序内存
* 

** 套接字 **
套接字屏蔽掉了linux内核中不同的差异，为应用程序提供统一的访问接口。每个套接字都有一个读写缓冲区。
* 读缓冲区，缓存了远端发过来的数据，如果缓冲区已满，就不能再接收新的数据。
* 写缓冲区，缓存了要发出去的数据，如果写缓冲区已满，应用程序的写操作就会被阻塞。
