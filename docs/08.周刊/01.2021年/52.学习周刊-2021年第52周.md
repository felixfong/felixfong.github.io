---
title: 学习周刊-2021年第52周
date: 2021-12-25 23:28:34
permalink: /weekly/pages/211225232834/
categories:
    - 周刊
    - 2021年
tags:
    -
---

### **0. 前言**

公司最近某部门出了技术季刊书籍，整体书籍知识点还是挺全面的，我们要吸取其精华，本期周刊就总结下相关知识点。

```html
疑惑：
- 计算机是如何计算的，CPU、内存、硬件是如何协作的关系
- 计算机为了提升处理问题的能力，做了哪些演进，从而引出网络IO复用
```

### **1. CPU、内存、操作系统协作关系**

CPU全称是Central Processing Unit, 它是电脑中最硬核的组件，CPU的核心是从程序或应用程序获取指令并执行计算，此过程分为三个阶段：提取、解码和执行。CPU从内存中提取指令，然后解码该指令的实际内容，然后再由CPU的相关部分执行该指令。

几乎所有的冯·诺伊曼型计算机的CPU，其工作都可以分为5个阶段：取指令、指令译码、执行指令、访存取数、结果写回。


::: tip

- 取指令阶段是将内存中的指令读取到CPU中寄存器的过程，程序寄存器用于存储下一条指令所在的地址。
- 指令译码阶段，在取指令完成后，立马进入指令译码阶段，在指令译码阶段，指令译码器按照预定的指令格式，对取回的指令进行拆分和解释，识别区分出不同的指令类别以及各种获取操作数的方法。
- 执行指令阶段，译码完成后，就需要执行这一条指令了，此阶段的任务是完成指令所规定的各种操作，具体实现指令的功能。
- 访问取数阶段，根据指令的需要，有可能需要从内存中提取数据，此阶段的任务是：根据指令地址码，得到操作数在主存中的地址，并从主存中读取该操作数用于运算。
- 结果写回阶段，作为最后一个阶段，结果写回（Write Back，WB）阶段把执行指令阶段的运行结果数据“写回”到某种存储形式：结果数据经常被写到CPU的内部寄存器中，以便被后续的指令快速地存取；

:::

内存（Memory）是程序与CPU进行沟通的桥梁，计算机中所有程序的运行都是在内存中进行的，内存又称为主存，其作用是存放CPU中的运算数据，以及与硬盘等外部存储设备交换的数据。只要计算机在运行中，CPU就会把需要运算的数据调到主存中进行运算，当运算完成后CPU再将结果传送出来。

不知道你是否会思考过，为什么CPU不直接与硬盘交换数据，而是和内存交换数据。曾几何时，这个问题困扰了我好久，翻阅资料才知道：CPU速度非常快，而硬盘等外存储器速度非常慢，如果让CPU访问外存储器，CPU将浪费大量的时间来等待外存的返回数据；而内存的读写速度远远高于外存，因此CPU直接从内存中获取数据更能最大化利用CPU的利用率。


### **2. 网络IO复用并发模型**

socket编程步骤：进程中的主线程main thread 创建一个ListenFd(服务端监听套接字), 将这个ListenFd绑定到需要服务的IP和端口上，然后执行阻塞Accept被动等待远程的客户端建立链接，每次客户端connect链接过来，main thread 中 accept 响应并建立链接。

- 阻塞等待，代表单线程accept(无IO复用)、单线程accept+多线程读写业务(无IO复用)
- 非阻塞忙轮训
- select，代表单线程多路IO复用、单线程多路IO复用+多线程读写业务(业务工作池)
- epoll，代表单线程多路IO复用+多线程IO复用(链接线程池)、单进程多路IO复用+多进程IO复用

### **3. Go单元测试**

谨记：repo中使用依赖倒置原则，以便于隔离数据来源测试代码功能；其中常用的工具包：

- github.com/stretchr/testify
- github.com/vektra/mockery生成mock文件，命令：
```shell
cd app/repository && mockery --name=UserRepository --case underscore --output ../mocks
```
- github.com/stretchr/testify/suite，当一个包中的被测对象有可能很多时，可以对单元测试进行组织
